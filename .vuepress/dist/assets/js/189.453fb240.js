(window.webpackJsonp=window.webpackJsonp||[]).push([[189],{632:function(e,t,r){"use strict";r.r(t);var o=r(1),a=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"concepts"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#concepts"}},[e._v("#")]),e._v(" Concepts")]),e._v(" "),t("h2",{attrs:{id:"evmos-dapp-store"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#evmos-dapp-store"}},[e._v("#")]),e._v(" Evmos dApp Store")]),e._v(" "),t("p",[e._v("The Evmos dApp store is a revenue-per-transaction model, which allows developers to get payed for deploying their decentralized application (dApps) on Evmos. Developers generate revenue, every time a user interacts with their dApp in the dApp store, gaining them a steady income. Users can discover new applications in the dApp store and pay for the transaction fees that finance the dApp's revenue. This value-reward exchange of dApp services for transaction fees is implemented by the "),t("code",[e._v("x/revenue")]),e._v(" module.")]),e._v(" "),t("h2",{attrs:{id:"registration"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#registration"}},[e._v("#")]),e._v(" Registration")]),e._v(" "),t("p",[e._v("Developers register their application in the dApp store by registering their application's smart contracts. Any contract can be registered by a developer by submitting a signed transaction. The signer of this transaction must match the address of the deployer of the contract in order for the registration to succeed. After the transaction is executed successfully, the developer will start receiving a portion of the transaction fees paid when a user interacts with the registered contract.")]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",[t("strong",[e._v("NOTE")]),e._v(": If your contract is part of a developer project, please ensure that the deployer of the contract (or the factory that deployes the contract) is an account that is owned by that project. This avoids the situtation, that an individual deployer who leaves your project could become malicious.")])]),e._v(" "),t("h2",{attrs:{id:"fee-distribution"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fee-distribution"}},[e._v("#")]),e._v(" Fee Distribution")]),e._v(" "),t("p",[e._v("As described above, developers will earn a portion of the transaction fee after registering their contracts. To understand how transaction fees are distributed, we look at the following two things in detail:")]),e._v(" "),t("ul",[t("li",[e._v("The transactions eligible are only "),t("a",{attrs:{href:"https://docs.evmos.org/modules/evm/",target:"_blank",rel:"noopener noreferrer"}},[e._v("EVM transactions"),t("OutboundLink")],1),e._v(" ("),t("code",[e._v("MsgEthereumTx")]),e._v("). Cosmos SDK transactions are not eligible at this time.")]),e._v(" "),t("li",[e._v("The registration of factory contracts (smart contracts that have been deployed by other contracts) requires the identification original contract's deployer. This is done through address derivation.")])]),e._v(" "),t("h3",{attrs:{id:"evm-transaction-fees"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#evm-transaction-fees"}},[e._v("#")]),e._v(" EVM Transaction Fees")]),e._v(" "),t("p",[e._v("Users pay transaction fees to pay interact with smart contracts using the EVM. When a transaction is executed, the entire fee amount ("),t("code",[e._v("gasLimit * gasPrice")]),e._v(") is sent to the "),t("code",[e._v("FeeCollector")]),e._v(" module account during the "),t("a",{attrs:{href:"https://docs.cosmos.network/main/modules/auth#antehandlers",target:"_blank",rel:"noopener noreferrer"}},[e._v("Cosmos SDK AnteHandler"),t("OutboundLink")],1),e._v(" execution. After the EVM executes the transaction, the user receives a refund of "),t("code",[e._v("(gasLimit - gasUsed) * gasPrice")]),e._v(". In result a user pays a total transaction fee of "),t("code",[e._v("txFee = gasUsed * gasPrice")]),e._v(" for the execution.")]),e._v(" "),t("p",[e._v("This transaction fee is distributed between developers and validators, in accordance with the "),t("code",[e._v("x/revenue")]),e._v(" module parameters: "),t("code",[e._v("DeveloperShares")]),e._v(", "),t("code",[e._v("ValidatorShares")]),e._v(". This distribution is handled through the EVM's "),t("RouterLink",{attrs:{to:"/modules/revenue/05_hooks.html"}},[t("code",[e._v("PostTxProcessing")]),e._v(" Hook")]),e._v(".")],1),e._v(" "),t("h3",{attrs:{id:"address-derivation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#address-derivation"}},[e._v("#")]),e._v(" Address Derivation")]),e._v(" "),t("p",[e._v("dApp developers might use a "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Factory_method_pattern",target:"_blank",rel:"noopener noreferrer"}},[e._v("factory pattern"),t("OutboundLink")],1),e._v(" to implement their application logic through smart contracts. In this case a smart contract can be either deployed by an Externally Owned Account ("),t("a",{attrs:{href:"https://ethereum.org/en/whitepaper/#ethereum-accounts",target:"_blank",rel:"noopener noreferrer"}},[e._v("EOA"),t("OutboundLink")],1),e._v(": an account controlled by a private key, that can sign transactions) or through another contract.")]),e._v(" "),t("p",[e._v("In both cases, the fee distribution requires the identification a deployer address that is an EOA address, unless a withdrawal address is set by the contract deployer during registration to receive transaction fees for a registered smart contract. If a withdrawal address is not set, it defaults to the deployer’s address.")]),e._v(" "),t("p",[e._v("The identification of the deployer address is done through address derivation. When registering a smart contract, the deployer provides an array of nonces, used to "),t("a",{attrs:{href:"https://github.com/ethereum/go-ethereum/blob/d8ff53dfb8a516f47db37dbc7fd7ad18a1e8a125/crypto/crypto.go#L107-L111",target:"_blank",rel:"noopener noreferrer"}},[e._v("derive the contract’s address"),t("OutboundLink")],1),e._v(":")]),e._v(" "),t("ul",[t("li",[e._v("If "),t("code",[e._v("MyContract")]),e._v(" is deployed directly by "),t("code",[e._v("DeployerEOA")]),e._v(", in a transaction sent with nonce "),t("code",[e._v("5")]),e._v(", then the array of nonces is "),t("code",[e._v("[5]")]),e._v(".")]),e._v(" "),t("li",[e._v("If the contract was created by a smart contract, through the "),t("code",[e._v("CREATE")]),e._v(" opcode, we need to provide all the nonces from the creation path. E.g. if "),t("code",[e._v("DeployerEOA")]),e._v(" deploys a "),t("code",[e._v("FactoryA")]),e._v(" smart contract with nonce "),t("code",[e._v("5")]),e._v(". Then, "),t("code",[e._v("DeployerEOA")]),e._v(" sends a transaction to "),t("code",[e._v("FactoryA")]),e._v(" through which a "),t("code",[e._v("FactoryB")]),e._v(" smart contract is created. If we assume "),t("code",[e._v("FactoryB")]),e._v(" is the second contract created by "),t("code",[e._v("FactoryA")]),e._v(", then "),t("code",[e._v("FactoryA")]),e._v("'s nonce is "),t("code",[e._v("2")]),e._v(". Then, "),t("code",[e._v("DeployerEOA")]),e._v(" sends a transaction to the "),t("code",[e._v("FactoryB")]),e._v(" contract, through which "),t("code",[e._v("MyContract")]),e._v(" is created. If this is the first contract created by "),t("code",[e._v("FactoryB")]),e._v(" - the nonce is "),t("code",[e._v("1")]),e._v(". We now have an address derivation path of "),t("code",[e._v("DeployerEOA")]),e._v(" -> "),t("code",[e._v("FactoryA")]),e._v(" -> "),t("code",[e._v("FactoryB")]),e._v(" -> "),t("code",[e._v("MyContract")]),e._v(". To be able to verify that "),t("code",[e._v("DeployerEOA")]),e._v(" can register "),t("code",[e._v("MyContract")]),e._v(", we need to provide the following nonces: "),t("code",[e._v("[5, 2, 1]")]),e._v(".")])]),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",[t("strong",[e._v("Note")]),e._v(": Even if "),t("code",[e._v("MyContract")]),e._v(" is created from "),t("code",[e._v("FactoryB")]),e._v(" through a transaction sent by an account different from "),t("code",[e._v("DeployerEOA")]),e._v(", only "),t("code",[e._v("DeployerEOA")]),e._v(" can register "),t("code",[e._v("MyContract")]),e._v(".")])])])}),[],!1,null,null,null);t.default=a.exports}}]);